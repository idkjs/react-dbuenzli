// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Weak = require("bs-platform/lib/js/weak.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_float = require("bs-platform/lib/js/caml_float.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var err_fix = "trying to fix a delayed value";

var err_step_executed = "step already executed";

function is_empty(a) {
  try {
    for(var i = 0 ,i_finish = a[/* len */1] - 1 | 0; i <= i_finish; ++i){
      if (Weak.check(a[/* arr */0], i)) {
        throw Pervasives.Exit;
      }
      
    }
    return true;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return false;
    } else {
      throw exn;
    }
  }
}

function clear(a) {
  a[/* arr */0] = Weak.create(0);
  a[/* len */1] = 0;
  return /* () */0;
}

function set(a, i) {
  var partial_arg = a[/* arr */0];
  return (function (param) {
      return Weak.set(partial_arg, i, param);
    });
}

function swap(a, i, i$prime) {
  var v = Weak.get(a[/* arr */0], i$prime);
  Weak.blit(a[/* arr */0], i, a[/* arr */0], i$prime, 1);
  return Weak.set(a[/* arr */0], i, v);
}

function grow(a) {
  var arr$prime = Weak.create(((a[/* len */1] + 1 | 0) << 1));
  Weak.blit(a[/* arr */0], 0, arr$prime, 0, a[/* len */1]);
  a[/* arr */0] = arr$prime;
  return /* () */0;
}

function add(a, v) {
  if (a[/* len */1] === Weak.length(a[/* arr */0])) {
    grow(a);
  }
  Weak.set(a[/* arr */0], a[/* len */1], Caml_option.some(v));
  a[/* len */1] = a[/* len */1] + 1 | 0;
  return /* () */0;
}

function scan_add(a, v) {
  try {
    for(var i = 0 ,i_finish = a[/* len */1] - 1 | 0; i <= i_finish; ++i){
      var match = Weak.get(a[/* arr */0], i);
      if (match === undefined) {
        Weak.set(a[/* arr */0], i, Caml_option.some(v));
        throw Pervasives.Exit;
      }
      
    }
    return add(a, v);
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function rem_last(a) {
  var l = a[/* len */1] - 1 | 0;
  a[/* len */1] = l;
  return Weak.set(a[/* arr */0], l, undefined);
}

function rem(a, v) {
  try {
    for(var i = 0 ,i_finish = a[/* len */1] - 1 | 0; i <= i_finish; ++i){
      var match = Weak.get(a[/* arr */0], i);
      if (match !== undefined) {
        if (v === Caml_option.valFromOption(match)) {
          Weak.set(a[/* arr */0], i, undefined);
          throw Pervasives.Exit;
        }
        
      }
      
    }
    return /* () */0;
  }
  catch (exn){
    if (exn === Pervasives.Exit) {
      return /* () */0;
    } else {
      throw exn;
    }
  }
}

function fold(f, acc, a) {
  var acc$1 = acc;
  for(var i = 0 ,i_finish = a[/* len */1] - 1 | 0; i <= i_finish; ++i){
    var match = Weak.get(a[/* arr */0], i);
    if (match !== undefined) {
      acc$1 = Curry._2(f, acc$1, Caml_option.valFromOption(match));
    }
    
  }
  return acc$1;
}

function els(h) {
  return fold((function (acc, e) {
                return /* :: */[
                        e,
                        acc
                      ];
              }), /* [] */0, h);
}

function compare_down(h, i, i$prime) {
  var match = Weak.get(h[/* arr */0], i);
  var match$1 = Weak.get(h[/* arr */0], i$prime);
  if (match !== undefined) {
    if (match$1 !== undefined) {
      return Caml_primitive.caml_int_compare(match[/* rank */0], match$1[/* rank */0]);
    } else {
      return 1;
    }
  } else if (match$1 !== undefined) {
    return -1;
  } else {
    return 0;
  }
}

function down(h, _i) {
  while(true) {
    var i = _i;
    var last = h[/* len */1] - 1 | 0;
    var start = (i << 1);
    var l = start + 1 | 0;
    var r = start + 2 | 0;
    if (l > last) {
      return /* () */0;
    } else {
      var child = r > last || compare_down(h, l, r) < 0 ? l : r;
      if (compare_down(h, i, child) > 0) {
        swap(h, i, child);
        _i = child;
        continue ;
      } else {
        return 0;
      }
    }
  };
}

function rebuild(h) {
  for(var i = (h[/* len */1] - 2 | 0) / 2 | 0; i >= 0; --i){
    down(h, i);
  }
  return /* () */0;
}

function take(h) {
  while(true) {
    var s = h[/* len */1];
    if (s === 0) {
      return undefined;
    } else {
      var v = Weak.get(h[/* arr */0], 0);
      if (s > 1) {
        set(h, 0)(Weak.get(h[/* arr */0], s - 1 | 0));
        rem_last(h);
        down(h, 0);
      } else {
        rem_last(h);
      }
      if (v !== undefined) {
        return v;
      } else {
        continue ;
      }
    }
  };
}

var nil = /* record */[
  /* over */true,
  /* heap : record */[
    /* arr */Weak.create(0),
    /* len */0
  ],
  /* eops : [] */0,
  /* cops : [] */0
];

function create(param) {
  var h = /* record */[
    /* arr */Weak.create(11),
    /* len */0
  ];
  return /* record */[
          /* over */false,
          /* heap */h,
          /* eops : [] */0,
          /* cops : [] */0
        ];
}

function add$1(c, n) {
  if (n[/* stamp */1] === c) {
    return /* () */0;
  } else {
    n[/* stamp */1] = c;
    var h = c[/* heap */1];
    var n$1 = n;
    add(h, n$1);
    var h$1 = h;
    var i = h[/* len */1] - 1 | 0;
    var h$2 = h$1;
    var _i = i;
    var _last_none = false;
    while(true) {
      var last_none = _last_none;
      var i$1 = _i;
      if (i$1 === 0) {
        if (last_none) {
          return down(h$2, 0);
        } else {
          return 0;
        }
      } else {
        var p = (i$1 - 1 | 0) / 2 | 0;
        var match = Weak.get(h$2[/* arr */0], i$1);
        var match$1 = Weak.get(h$2[/* arr */0], p);
        if (match !== undefined) {
          if (match$1 !== undefined) {
            if (match[/* rank */0] < match$1[/* rank */0]) {
              swap(h$2, i$1, p);
              _last_none = false;
              _i = p;
              continue ;
            } else if (last_none) {
              return down(h$2, i$1);
            } else {
              return 0;
            }
          } else {
            swap(h$2, i$1, p);
            _last_none = true;
            _i = p;
            continue ;
          }
        } else {
          return /* () */0;
        }
      }
    };
  }
}

function add_deps(c, n) {
  var f = function (param) {
    return add$1(c, param);
  };
  var a = n[/* deps */5];
  for(var i = 0 ,i_finish = a[/* len */1] - 1 | 0; i <= i_finish; ++i){
    var match = Weak.get(a[/* arr */0], i);
    if (match !== undefined) {
      Curry._1(f, Caml_option.valFromOption(match));
    }
    
  }
  return /* () */0;
}

function add_eop(c, op) {
  c[/* eops */2] = /* :: */[
    op,
    c[/* eops */2]
  ];
  return /* () */0;
}

function add_cop(c, op) {
  c[/* cops */3] = /* :: */[
    op,
    c[/* cops */3]
  ];
  return /* () */0;
}

function execute(c) {
  var eops = function (c) {
    List.iter((function (op) {
            return Curry._1(op, /* () */0);
          }), c[/* eops */2]);
    c[/* eops */2] = /* [] */0;
    return /* () */0;
  };
  var cops = function (c) {
    List.iter((function (op) {
            return Curry._1(op, /* () */0);
          }), c[/* cops */3]);
    c[/* cops */3] = /* [] */0;
    return /* () */0;
  };
  var finish = function (c) {
    c[/* over */0] = true;
    c[/* heap */1] = /* record */[
      /* arr */Weak.create(0),
      /* len */0
    ];
    return /* () */0;
  };
  var c$1 = c;
  while(true) {
    var match = take(c$1[/* heap */1]);
    if (match !== undefined) {
      var n = match;
      if (n[/* rank */0] !== Pervasives.max_int) {
        Curry._1(n[/* update */4], c$1);
        continue ;
      } else {
        var c$prime = create(/* () */0);
        eops(c$1);
        List.iter((function(c$prime){
            return function (n) {
              return Curry._1(n[/* update */4], c$prime);
            }
            }(c$prime)), /* :: */[
              n,
              els(c$1[/* heap */1])
            ]);
        cops(c$1);
        finish(c$1);
        return execute(c$prime);
      }
    } else {
      eops(c$1);
      cops(c$1);
      return finish(c$1);
    }
  };
}

function execute$1(c) {
  if (c[/* over */0]) {
    return Pervasives.invalid_arg(err_step_executed);
  } else {
    return execute(c);
  }
}

function find_unfinished(nl) {
  var aux = function (_next, _param) {
    while(true) {
      var param = _param;
      var next = _next;
      if (param) {
        var nl = param[0];
        if (nl) {
          var _next$1 = next;
          var todo = param[1];
          var _param$1 = nl;
          while(true) {
            var param$1 = _param$1;
            var next$1 = _next$1;
            if (param$1) {
              var n = param$1[0];
              if (n[/* stamp */1][/* over */0]) {
                _param$1 = param$1[1];
                _next$1 = /* :: */[
                  Curry._1(n[/* producers */3], /* () */0),
                  next$1
                ];
                continue ;
              } else {
                return n[/* stamp */1];
              }
            } else {
              return aux(next$1, todo);
            }
          };
        } else {
          _param = param[1];
          continue ;
        }
      } else if (next === /* [] */0) {
        return nil;
      } else {
        _param = next;
        _next = /* [] */0;
        continue ;
      }
    };
  };
  return aux(/* [] */0, /* :: */[
              nl,
              /* [] */0
            ]);
}

var max_rank = Pervasives.max_int - 1 | 0;

function nop(param) {
  return /* () */0;
}

function no_producers(param) {
  return /* [] */0;
}

function create$1(r) {
  return /* record */[
          /* rank */r,
          /* stamp */nil,
          /* retain */nop,
          /* producers */no_producers,
          /* update */nop,
          /* deps : record */[
            /* arr */Weak.create(0),
            /* len */0
          ]
        ];
}

function deps(n) {
  return fold((function (acc, d) {
                return /* :: */[
                        d,
                        acc
                      ];
              }), /* [] */0, n[/* deps */5]);
}

function bind(n, p, u) {
  n[/* producers */3] = p;
  n[/* update */4] = u;
  return /* () */0;
}

function stop($staropt$star, n) {
  var strong = $staropt$star !== undefined ? $staropt$star : false;
  if (strong) {
    var producers = Curry._1(n[/* producers */3], /* () */0);
    n[/* producers */3] = no_producers;
    n[/* update */4] = nop;
    clear(n[/* deps */5]);
    var _next = /* [] */0;
    var _to_rem = n;
    var _param = producers;
    while(true) {
      var param = _param;
      var to_rem = _to_rem;
      var next = _next;
      if (param) {
        var todo = param[1];
        var n$1 = param[0];
        rem(n$1[/* deps */5], to_rem);
        if (n$1[/* rank */0] === Pervasives.min_int || !is_empty(n$1[/* deps */5])) {
          _param = todo;
          continue ;
        } else {
          var prods = Curry._1(n$1[/* producers */3], /* () */0);
          n$1[/* producers */3] = no_producers;
          n$1[/* update */4] = nop;
          clear(n$1[/* deps */5]);
          _param = todo;
          _next = /* :: */[
            /* tuple */[
              n$1,
              prods
            ],
            next
          ];
          continue ;
        }
      } else if (next) {
        var match = next[0];
        _param = match[1];
        _to_rem = match[0];
        _next = next[1];
        continue ;
      } else {
        return /* () */0;
      }
    };
  } else {
    n[/* producers */3] = no_producers;
    n[/* update */4] = nop;
    return clear(n[/* deps */5]);
  }
}

var rmin = create$1(Pervasives.min_int);

function rmax(n, n$prime) {
  if (n[/* rank */0] > n$prime[/* rank */0]) {
    return n;
  } else {
    return n$prime;
  }
}

function rsucc(n) {
  if (n[/* rank */0] === Pervasives.max_int) {
    return Pervasives.min_int;
  } else if (n[/* rank */0] < max_rank) {
    return n[/* rank */0] + 1 | 0;
  } else {
    return Pervasives.invalid_arg("maximal rank exceeded");
  }
}

function rsucc2(n, n$prime) {
  var r = rsucc(n);
  var r$prime = rsucc(n$prime);
  if (r > r$prime) {
    return r;
  } else {
    return r$prime;
  }
}

function update_rank(n, r) {
  var aux = function (_param) {
    while(true) {
      var param = _param;
      if (param) {
        var n = param[0];
        var update = (function(n){
        return function update(todo, d) {
          if (n[/* rank */0] < d[/* rank */0] || n[/* rank */0] === Pervasives.max_int) {
            return todo;
          } else {
            d[/* rank */0] = rsucc(n);
            return /* :: */[
                    d,
                    todo
                  ];
          }
        }
        }(n));
        _param = fold(update, param[1], n[/* deps */5]);
        continue ;
      } else {
        return /* () */0;
      }
    };
  };
  if (r > n[/* rank */0]) {
    n[/* rank */0] = r;
    aux(/* :: */[
          n,
          /* [] */0
        ]);
    return true;
  } else {
    return false;
  }
}

function $$eval(m) {
  var match = m[/* ev */0][0];
  if (match !== undefined) {
    return Caml_option.valFromOption(match);
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "React.re",
            568,
            12
          ]
        ];
  }
}

function emut(rank) {
  return /* record */[
          /* ev : record */[/* contents */undefined],
          /* enode */create$1(rank)
        ];
}

function $$event(m, p, u) {
  bind(m[/* enode */1], p, u);
  return /* Emut */[m];
}

function eupdate(v, m, c) {
  m[/* ev */0][0] = Caml_option.some(v);
  var partial_arg = m[/* ev */0];
  add_cop(c, (function (param) {
          partial_arg[0] = undefined;
          return /* () */0;
        }));
  return add_deps(c, m[/* enode */1]);
}

function sval(m) {
  var match = m[/* sv */0];
  if (match !== undefined) {
    return Caml_option.valFromOption(match);
  } else {
    throw [
          Caml_builtin_exceptions.assert_failure,
          /* tuple */[
            "React.re",
            589,
            12
          ]
        ];
  }
}

function smut(rank, eq) {
  return /* record */[
          /* sv */undefined,
          /* eq */eq,
          /* snode */create$1(rank)
        ];
}

function signal(i, m, p, u) {
  bind(m[/* snode */2], p, u);
  if (i !== undefined) {
    m[/* sv */0] = i;
  }
  var c = find_unfinished(Curry._1(m[/* snode */2][/* producers */3], /* () */0));
  if (c === nil) {
    Curry._1(m[/* snode */2][/* update */4], nil);
  } else {
    add$1(c, m[/* snode */2]);
  }
  return /* Smut */Block.__(1, [m]);
}

function supdate(v, m, c) {
  var match = m[/* sv */0];
  if (match !== undefined) {
    if (Curry._2(m[/* eq */1], v, Caml_option.valFromOption(match))) {
      return /* () */0;
    } else {
      m[/* sv */0] = Caml_option.some(v);
      if (c !== nil) {
        return add_deps(c, m[/* snode */2]);
      } else {
        return 0;
      }
    }
  } else {
    m[/* sv */0] = Caml_option.some(v);
    return /* () */0;
  }
}

function add_dep(m, n) {
  scan_add(m[/* enode */1][/* deps */5], n);
  if (m[/* ev */0][0] !== undefined) {
    return add$1(m[/* enode */1][/* stamp */1], n);
  } else {
    return 0;
  }
}

function create$2(param) {
  var m = emut(Pervasives.min_int);
  return /* tuple */[
          /* Emut */[m],
          (function (param, param$1) {
              var m$1 = m;
              var step = param;
              var v = param$1;
              if (step !== undefined) {
                var c = step;
                if (c[/* over */0]) {
                  Pervasives.invalid_arg(err_step_executed);
                } else if (m$1[/* enode */1][/* stamp */1][/* over */0]) {
                  m$1[/* enode */1][/* stamp */1] = c;
                } else {
                  Pervasives.invalid_arg("event already scheduled on a step");
                }
                return eupdate(v, m$1, c);
              } else {
                var c$1 = create(/* () */0);
                m$1[/* enode */1][/* stamp */1] = c$1;
                eupdate(v, m$1, c$1);
                return execute$1(c$1);
              }
            })
        ];
}

function retain(e, c) {
  if (e) {
    var m = e[0];
    var c$prime = m[/* enode */1][/* retain */2];
    m[/* enode */1][/* retain */2] = c;
    return /* `R */[
            82,
            c$prime
          ];
  } else {
    return Pervasives.invalid_arg("E.never cannot retain a closure");
  }
}

function stop$1(strong, param) {
  if (param) {
    return stop(strong, param[0][/* enode */1]);
  } else {
    return /* () */0;
  }
}

function equal(e, e$prime) {
  if (e) {
    if (e$prime) {
      return e[0] === e$prime[0];
    } else {
      return false;
    }
  } else if (e$prime) {
    return false;
  } else {
    return true;
  }
}

function trace($staropt$star, t, e) {
  var iff = $staropt$star !== undefined ? $staropt$star : /* Const */Block.__(0, [true]);
  if (iff.tag) {
    if (e) {
      var m = e[0];
      var mc = iff[0];
      var m$prime = emut(rsucc2(mc[/* snode */2], m[/* enode */1]));
      var p = function (param) {
        return /* :: */[
                mc[/* snode */2],
                /* :: */[
                  m[/* enode */1],
                  /* [] */0
                ]
              ];
      };
      var u = function (c) {
        var match = m[/* ev */0][0];
        if (match !== undefined) {
          var v = Caml_option.valFromOption(match);
          if (sval(mc)) {
            Curry._1(t, v);
          }
          return eupdate(v, m$prime, c);
        } else {
          return /* () */0;
        }
      };
      scan_add(mc[/* snode */2][/* deps */5], m$prime[/* enode */1]);
      add_dep(m, m$prime[/* enode */1]);
      return $$event(m$prime, p, u);
    } else {
      return /* Never */0;
    }
  } else if (iff[0] && e) {
    var m$1 = e[0];
    var m$prime$1 = emut(rsucc(m$1[/* enode */1]));
    var p$1 = function (param) {
      return /* :: */[
              m$1[/* enode */1],
              /* [] */0
            ];
    };
    var u$1 = function (c) {
      var v = $$eval(m$1);
      Curry._1(t, v);
      return eupdate(v, m$prime$1, c);
    };
    add_dep(m$1, m$prime$1[/* enode */1]);
    return $$event(m$prime$1, p$1, u$1);
  } else {
    return e;
  }
}

function once(param) {
  if (param) {
    var m = param[0];
    var m$prime = emut(rsucc(m[/* enode */1]));
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* [] */0
            ];
    };
    var u = function (c) {
      rem(m[/* enode */1][/* deps */5], m$prime[/* enode */1]);
      eupdate($$eval(m), m$prime, c);
      return stop(undefined, m$prime[/* enode */1]);
    };
    add_dep(m, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function drop_once(param) {
  if (param) {
    var m = param[0];
    var m$prime = emut(rsucc(m[/* enode */1]));
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* [] */0
            ];
    };
    var u = function (c) {
      var u$prime = function (c) {
        return eupdate($$eval(m), m$prime, c);
      };
      return bind(m$prime[/* enode */1], p, u$prime);
    };
    add_dep(m, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function app(ef, param) {
  if (param && ef) {
    var mf = ef[0];
    var m = param[0];
    var m$prime = emut(rsucc2(m[/* enode */1], mf[/* enode */1]));
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* :: */[
                mf[/* enode */1],
                /* [] */0
              ]
            ];
    };
    var u = function (c) {
      var match = mf[/* ev */0][0];
      var match$1 = m[/* ev */0][0];
      if (match !== undefined && match$1 !== undefined) {
        return eupdate(Curry._1(match, Caml_option.valFromOption(match$1)), m$prime, c);
      } else {
        return /* () */0;
      }
    };
    add_dep(m, m$prime[/* enode */1]);
    add_dep(mf, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function map(f, param) {
  if (param) {
    var m = param[0];
    var m$prime = emut(rsucc(m[/* enode */1]));
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* [] */0
            ];
    };
    var u = function (c) {
      return eupdate(Curry._1(f, $$eval(m)), m$prime, c);
    };
    add_dep(m, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function stamp(e, v) {
  if (e) {
    var m = e[0];
    var m$prime = emut(rsucc(m[/* enode */1]));
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* [] */0
            ];
    };
    var u = function (c) {
      return eupdate(v, m$prime, c);
    };
    add_dep(m, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function filter(pred, param) {
  if (param) {
    var m = param[0];
    var m$prime = emut(rsucc(m[/* enode */1]));
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* [] */0
            ];
    };
    var u = function (c) {
      var v = $$eval(m);
      if (Curry._1(pred, v)) {
        return eupdate(v, m$prime, c);
      } else {
        return /* () */0;
      }
    };
    add_dep(m, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function fmap(fm, param) {
  if (param) {
    var m = param[0];
    var m$prime = emut(rsucc(m[/* enode */1]));
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* [] */0
            ];
    };
    var u = function (c) {
      var match = Curry._1(fm, $$eval(m));
      if (match !== undefined) {
        return eupdate(Caml_option.valFromOption(match), m$prime, c);
      } else {
        return /* () */0;
      }
    };
    add_dep(m, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function diff(d, param) {
  if (param) {
    var m = param[0];
    var m$prime = emut(rsucc(m[/* enode */1]));
    var last = /* record */[/* contents */undefined];
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* [] */0
            ];
    };
    var u = function (c) {
      var v = $$eval(m);
      var match = last[0];
      if (match !== undefined) {
        last[0] = Caml_option.some(v);
        return eupdate(Curry._2(d, v, Caml_option.valFromOption(match)), m$prime, c);
      } else {
        last[0] = Caml_option.some(v);
        return /* () */0;
      }
    };
    add_dep(m, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function changes($staropt$star, param) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  if (param) {
    var m = param[0];
    var m$prime = emut(rsucc(m[/* enode */1]));
    var last = /* record */[/* contents */undefined];
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* [] */0
            ];
    };
    var u = function (c) {
      var v = $$eval(m);
      var match = last[0];
      if (match !== undefined) {
        last[0] = Caml_option.some(v);
        if (Curry._2(eq, v, Caml_option.valFromOption(match))) {
          return /* () */0;
        } else {
          return eupdate(v, m$prime, c);
        }
      } else {
        last[0] = Caml_option.some(v);
        return eupdate(v, m$prime, c);
      }
    };
    add_dep(m, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function on(c, e) {
  if (e) {
    var m = e[0];
    if (c.tag) {
      var mc = c[0];
      var m$prime = emut(rsucc2(m[/* enode */1], mc[/* snode */2]));
      var p = function (param) {
        return /* :: */[
                m[/* enode */1],
                /* :: */[
                  mc[/* snode */2],
                  /* [] */0
                ]
              ];
      };
      var u = function (c) {
        var match = m[/* ev */0][0];
        if (match !== undefined && sval(mc)) {
          return eupdate($$eval(m), m$prime, c);
        } else {
          return /* () */0;
        }
      };
      add_dep(m, m$prime[/* enode */1]);
      scan_add(mc[/* snode */2][/* deps */5], m$prime[/* enode */1]);
      return $$event(m$prime, p, u);
    } else if (c[0]) {
      return e;
    } else {
      return /* Never */0;
    }
  } else {
    return /* Never */0;
  }
}

function dismiss(c, e) {
  if (e) {
    if (c) {
      var mc = c[0];
      var m = e[0];
      var m$prime = emut(rsucc2(mc[/* enode */1], m[/* enode */1]));
      var p = function (param) {
        return /* :: */[
                mc[/* enode */1],
                /* :: */[
                  m[/* enode */1],
                  /* [] */0
                ]
              ];
      };
      var u = function (c) {
        var match = mc[/* ev */0][0];
        if (match !== undefined) {
          return /* () */0;
        } else {
          return eupdate($$eval(m), m$prime, c);
        }
      };
      add_dep(mc, m$prime[/* enode */1]);
      add_dep(m, m$prime[/* enode */1]);
      return $$event(m$prime, p, u);
    } else {
      return e;
    }
  } else {
    return /* Never */0;
  }
}

function until(c, e) {
  if (e) {
    if (c) {
      var mc = c[0];
      var m = e[0];
      var m$prime = emut(rsucc2(m[/* enode */1], mc[/* enode */1]));
      var p = function (param) {
        return /* :: */[
                m[/* enode */1],
                /* :: */[
                  mc[/* enode */1],
                  /* [] */0
                ]
              ];
      };
      var u = function (c) {
        var match = mc[/* ev */0][0];
        if (match !== undefined) {
          rem(m[/* enode */1][/* deps */5], m$prime[/* enode */1]);
          rem(mc[/* enode */1][/* deps */5], m$prime[/* enode */1]);
          return stop(undefined, m$prime[/* enode */1]);
        } else {
          return eupdate($$eval(m), m$prime, c);
        }
      };
      add_dep(m, m$prime[/* enode */1]);
      add_dep(mc, m$prime[/* enode */1]);
      return $$event(m$prime, p, u);
    } else {
      return e;
    }
  } else {
    return /* Never */0;
  }
}

function accum(ef, i) {
  if (ef) {
    var m = ef[0];
    var m$prime = emut(rsucc(m[/* enode */1]));
    var acc = /* record */[/* contents */i];
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* [] */0
            ];
    };
    var u = function (c) {
      acc[0] = Curry._1($$eval(m), acc[0]);
      return eupdate(acc[0], m$prime, c);
    };
    add_dep(m, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function fold$1(f, i, param) {
  if (param) {
    var m = param[0];
    var m$prime = emut(rsucc(m[/* enode */1]));
    var acc = /* record */[/* contents */i];
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* [] */0
            ];
    };
    var u = function (c) {
      acc[0] = Curry._2(f, acc[0], $$eval(m));
      return eupdate(acc[0], m$prime, c);
    };
    add_dep(m, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function occurs(m) {
  return m[/* ev */0][0] !== undefined;
}

function find_muts_and_next_rank(el) {
  var _acc = /* [] */0;
  var _max = rmin;
  var _param = el;
  while(true) {
    var param = _param;
    var max = _max;
    var acc = _acc;
    if (param) {
      var match = param[0];
      if (match) {
        var m = match[0];
        _param = param[1];
        _max = rmax(max, m[/* enode */1]);
        _acc = /* :: */[
          m,
          acc
        ];
        continue ;
      } else {
        _param = param[1];
        continue ;
      }
    } else {
      return /* tuple */[
              List.rev(acc),
              rsucc(max)
            ];
    }
  };
}

function select(el) {
  var match = find_muts_and_next_rank(el);
  var emuts = match[0];
  var m$prime = emut(match[1]);
  var p = function (param) {
    return List.rev_map((function (m) {
                  return m[/* enode */1];
                }), emuts);
  };
  var u = function (c) {
    try {
      return eupdate($$eval(List.find(occurs, emuts)), m$prime, c);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "React.re",
                958,
                21
              ]
            ];
      }
      throw exn;
    }
  };
  List.iter((function (m) {
          return add_dep(m, m$prime[/* enode */1]);
        }), emuts);
  return $$event(m$prime, p, u);
}

function merge(f, a, el) {
  var fold = function (f, _acc, _param) {
    while(true) {
      var param = _param;
      var acc = _acc;
      if (param) {
        var l = param[1];
        var m = param[0];
        if (occurs(m)) {
          _param = l;
          _acc = Curry._2(f, acc, $$eval(m));
          continue ;
        } else {
          _param = l;
          continue ;
        }
      } else {
        return acc;
      }
    };
  };
  var match = find_muts_and_next_rank(el);
  var emuts = match[0];
  var m$prime = emut(match[1]);
  var p = function (param) {
    return List.rev_map((function (m) {
                  return m[/* enode */1];
                }), emuts);
  };
  var u = function (c) {
    return eupdate(fold(f, a, emuts), m$prime, c);
  };
  List.iter((function (m) {
          return add_dep(m, m$prime[/* enode */1]);
        }), emuts);
  return $$event(m$prime, p, u);
}

function $$switch(e, param) {
  if (param) {
    var ms = param[0];
    var r = e ? rsucc2(e[0][/* enode */1], ms[/* enode */1]) : rsucc(ms[/* enode */1]);
    var m$prime = emut(r);
    var src = /* record */[/* contents */e];
    var p = function (param) {
      var match = src[0];
      if (match) {
        return /* :: */[
                match[0][/* enode */1],
                /* :: */[
                  ms[/* enode */1],
                  /* [] */0
                ]
              ];
      } else {
        return /* :: */[
                ms[/* enode */1],
                /* [] */0
              ];
      }
    };
    var u = function (c) {
      var match = ms[/* ev */0][0];
      if (match !== undefined) {
        var e = match;
        var match$1 = src[0];
        if (match$1) {
          rem(match$1[0][/* enode */1][/* deps */5], m$prime[/* enode */1]);
        }
        src[0] = e;
        if (e) {
          var m = e[0];
          scan_add(m[/* enode */1][/* deps */5], m$prime[/* enode */1]);
          if (update_rank(m$prime[/* enode */1], rsucc2(m[/* enode */1], ms[/* enode */1]))) {
            m$prime[/* enode */1][/* stamp */1] = nil;
            return rebuild(c[/* heap */1]);
          } else {
            var match$2 = m[/* ev */0][0];
            if (match$2 !== undefined) {
              return eupdate(Caml_option.valFromOption(match$2), m$prime, c);
            } else {
              return /* () */0;
            }
          }
        } else {
          update_rank(m$prime[/* enode */1], rsucc(ms[/* enode */1]));
          return /* () */0;
        }
      } else {
        var match$3 = src[0];
        if (match$3) {
          return eupdate($$eval(match$3[0]), m$prime, c);
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "React.re",
                  998,
                  23
                ]
              ];
        }
      }
    };
    if (e) {
      add_dep(e[0], m$prime[/* enode */1]);
    }
    add_dep(ms, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return e;
  }
}

function fix(f) {
  var m = emut(Pervasives.max_int);
  var e = $$event(m, (function (param) {
          return /* [] */0;
        }), (function (param) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "React.re",
                  1035,
                  38
                ]
              ];
        }));
  var match = Curry._1(f, e);
  var match$1 = match[0];
  if (match$1) {
    var m$prime = match$1[0];
    if (m$prime[/* enode */1][/* rank */0] === Pervasives.max_int) {
      Pervasives.invalid_arg(err_fix);
    }
    var p = function (param) {
      return /* [] */0;
    };
    var u = function (c) {
      m[/* ev */0][0] = Caml_option.some($$eval(m$prime));
      var partial_arg = m[/* ev */0];
      add_eop(c, (function (param) {
              partial_arg[0] = undefined;
              return /* () */0;
            }));
      return add_deps(c, m[/* enode */1]);
    };
    bind(m[/* enode */1], p, u);
    add_dep(m$prime, m[/* enode */1]);
    return match[1];
  } else {
    return match[1];
  }
}

function l2(f, e0, e1) {
  if (e0 && e1) {
    var m1 = e1[0];
    var m0 = e0[0];
    var r = rsucc2(m0[/* enode */1], m1[/* enode */1]);
    var m$prime = emut(r);
    var p = function (param) {
      return /* :: */[
              m0[/* enode */1],
              /* :: */[
                m1[/* enode */1],
                /* [] */0
              ]
            ];
    };
    var u = function (c) {
      var match = m0[/* ev */0][0];
      var match$1 = m1[/* ev */0][0];
      if (match !== undefined && match$1 !== undefined) {
        return eupdate(Curry._2(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1)), m$prime, c);
      } else {
        return /* () */0;
      }
    };
    add_dep(m0, m$prime[/* enode */1]);
    add_dep(m1, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function l3(f, e0, e1, e2) {
  if (e0 && e1 && e2) {
    var m2 = e2[0];
    var m1 = e1[0];
    var m0 = e0[0];
    var r = rsucc(rmax(rmax(m0[/* enode */1], m1[/* enode */1]), m2[/* enode */1]));
    var m$prime = emut(r);
    var p = function (param) {
      return /* :: */[
              m0[/* enode */1],
              /* :: */[
                m1[/* enode */1],
                /* :: */[
                  m2[/* enode */1],
                  /* [] */0
                ]
              ]
            ];
    };
    var u = function (c) {
      var match = m0[/* ev */0][0];
      var match$1 = m1[/* ev */0][0];
      var match$2 = m2[/* ev */0][0];
      if (match !== undefined && match$1 !== undefined && match$2 !== undefined) {
        return eupdate(Curry._3(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1), Caml_option.valFromOption(match$2)), m$prime, c);
      } else {
        return /* () */0;
      }
    };
    add_dep(m0, m$prime[/* enode */1]);
    add_dep(m1, m$prime[/* enode */1]);
    add_dep(m2, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function l4(f, e0, e1, e2, e3) {
  if (e0 && e1 && e2 && e3) {
    var m3 = e3[0];
    var m2 = e2[0];
    var m1 = e1[0];
    var m0 = e0[0];
    var r = rsucc(rmax(rmax(m0[/* enode */1], m1[/* enode */1]), rmax(m2[/* enode */1], m3[/* enode */1])));
    var m$prime = emut(r);
    var p = function (param) {
      return /* :: */[
              m0[/* enode */1],
              /* :: */[
                m1[/* enode */1],
                /* :: */[
                  m2[/* enode */1],
                  /* :: */[
                    m3[/* enode */1],
                    /* [] */0
                  ]
                ]
              ]
            ];
    };
    var u = function (c) {
      var match = m0[/* ev */0][0];
      var match$1 = m1[/* ev */0][0];
      var match$2 = m2[/* ev */0][0];
      var match$3 = m3[/* ev */0][0];
      if (match !== undefined && match$1 !== undefined && match$2 !== undefined && match$3 !== undefined) {
        return eupdate(Curry._4(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1), Caml_option.valFromOption(match$2), Caml_option.valFromOption(match$3)), m$prime, c);
      } else {
        return /* () */0;
      }
    };
    add_dep(m0, m$prime[/* enode */1]);
    add_dep(m1, m$prime[/* enode */1]);
    add_dep(m2, m$prime[/* enode */1]);
    add_dep(m3, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function l5(f, e0, e1, e2, e3, e4) {
  if (e0 && e1 && e2 && e3 && e4) {
    var m4 = e4[0];
    var m3 = e3[0];
    var m2 = e2[0];
    var m1 = e1[0];
    var m0 = e0[0];
    var r = rsucc(rmax(rmax(rmax(m0[/* enode */1], m1[/* enode */1]), rmax(m2[/* enode */1], m3[/* enode */1])), m4[/* enode */1]));
    var m$prime = emut(r);
    var p = function (param) {
      return /* :: */[
              m0[/* enode */1],
              /* :: */[
                m1[/* enode */1],
                /* :: */[
                  m2[/* enode */1],
                  /* :: */[
                    m3[/* enode */1],
                    /* :: */[
                      m4[/* enode */1],
                      /* [] */0
                    ]
                  ]
                ]
              ]
            ];
    };
    var u = function (c) {
      var match = m0[/* ev */0][0];
      var match$1 = m1[/* ev */0][0];
      var match$2 = m2[/* ev */0][0];
      var match$3 = m3[/* ev */0][0];
      var match$4 = m4[/* ev */0][0];
      if (match !== undefined && match$1 !== undefined && match$2 !== undefined && match$3 !== undefined && match$4 !== undefined) {
        return eupdate(Curry._5(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1), Caml_option.valFromOption(match$2), Caml_option.valFromOption(match$3), Caml_option.valFromOption(match$4)), m$prime, c);
      } else {
        return /* () */0;
      }
    };
    add_dep(m0, m$prime[/* enode */1]);
    add_dep(m1, m$prime[/* enode */1]);
    add_dep(m2, m$prime[/* enode */1]);
    add_dep(m3, m$prime[/* enode */1]);
    add_dep(m4, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function l6(f, e0, e1, e2, e3, e4, e5) {
  if (e0 && e1 && e2 && e3 && e4 && e5) {
    var m5 = e5[0];
    var m4 = e4[0];
    var m3 = e3[0];
    var m2 = e2[0];
    var m1 = e1[0];
    var m0 = e0[0];
    var r = rsucc(rmax(rmax(rmax(m0[/* enode */1], m1[/* enode */1]), rmax(m2[/* enode */1], m3[/* enode */1])), rmax(m4[/* enode */1], m5[/* enode */1])));
    var m$prime = emut(r);
    var p = function (param) {
      return /* :: */[
              m0[/* enode */1],
              /* :: */[
                m1[/* enode */1],
                /* :: */[
                  m2[/* enode */1],
                  /* :: */[
                    m3[/* enode */1],
                    /* :: */[
                      m4[/* enode */1],
                      /* :: */[
                        m5[/* enode */1],
                        /* [] */0
                      ]
                    ]
                  ]
                ]
              ]
            ];
    };
    var u = function (c) {
      var match = m0[/* ev */0][0];
      var match$1 = m1[/* ev */0][0];
      var match$2 = m2[/* ev */0][0];
      var match$3 = m3[/* ev */0][0];
      var match$4 = m4[/* ev */0][0];
      var match$5 = m5[/* ev */0][0];
      if (match !== undefined && match$1 !== undefined && match$2 !== undefined && match$3 !== undefined && match$4 !== undefined && match$5 !== undefined) {
        return eupdate(Curry._6(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1), Caml_option.valFromOption(match$2), Caml_option.valFromOption(match$3), Caml_option.valFromOption(match$4), Caml_option.valFromOption(match$5)), m$prime, c);
      } else {
        return /* () */0;
      }
    };
    add_dep(m0, m$prime[/* enode */1]);
    add_dep(m1, m$prime[/* enode */1]);
    add_dep(m2, m$prime[/* enode */1]);
    add_dep(m3, m$prime[/* enode */1]);
    add_dep(m4, m$prime[/* enode */1]);
    add_dep(m5, m$prime[/* enode */1]);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function some(e) {
  return map((function (v) {
                return Caml_option.some(v);
              }), e);
}

function value($$default, e) {
  if ($$default !== undefined) {
    var match = $$default;
    if (match.tag) {
      if (e) {
        var m = e[0];
        var ms = match[0];
        var m$prime = emut(rsucc2(m[/* enode */1], ms[/* snode */2]));
        var p = function (param) {
          return /* :: */[
                  m[/* enode */1],
                  /* :: */[
                    ms[/* snode */2],
                    /* [] */0
                  ]
                ];
        };
        var u = function (c) {
          var match = m[/* ev */0][0];
          if (match !== undefined) {
            var match$1 = Caml_option.valFromOption(match);
            if (match$1 !== undefined) {
              return eupdate(Caml_option.valFromOption(match$1), m$prime, c);
            } else {
              return eupdate(sval(ms), m$prime, c);
            }
          } else {
            return /* () */0;
          }
        };
        add_dep(m, m$prime[/* enode */1]);
        scan_add(ms[/* snode */2][/* deps */5], m$prime[/* enode */1]);
        return $$event(m$prime, p, u);
      } else {
        return /* Never */0;
      }
    } else {
      var dv = match[0];
      return map((function (param) {
                    if (param !== undefined) {
                      return Caml_option.valFromOption(param);
                    } else {
                      return dv;
                    }
                  }), e);
    }
  } else {
    return fmap((function (v) {
                  return v;
                }), e);
  }
}

var $$Option = /* module */[
  /* some */some,
  /* value */value
];

function end_of_step_add_dep($staropt$star, stop_if_stopped, m, m$prime) {
  var post_add_op = $staropt$star !== undefined ? $staropt$star : (function (param) {
        return /* () */0;
      });
  var c = find_unfinished(Curry._1(m[/* snode */2][/* producers */3], /* () */0));
  if (c === nil) {
    scan_add(m[/* snode */2][/* deps */5], m$prime[/* enode */1]);
    return Curry._1(post_add_op, /* () */0);
  } else {
    var add_dep = function (param) {
      if (m[/* snode */2][/* update */4] === nop) {
        if (stop_if_stopped) {
          return stop(undefined, m$prime[/* enode */1]);
        } else {
          return 0;
        }
      } else {
        update_rank(m$prime[/* enode */1], rsucc(m[/* snode */2]));
        scan_add(m[/* snode */2][/* deps */5], m$prime[/* enode */1]);
        return Curry._1(post_add_op, /* () */0);
      }
    };
    return add_eop(c, add_dep);
  }
}

function $$const(v) {
  return /* Const */Block.__(0, [v]);
}

function create$3($staropt$star, v) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  var m = smut(Pervasives.min_int, eq);
  m[/* sv */0] = Caml_option.some(v);
  return /* tuple */[
          /* Smut */Block.__(1, [m]),
          (function (param, param$1) {
              var m$1 = m;
              var step = param;
              var v = param$1;
              if (Curry._2(m$1[/* eq */1], sval(m$1), v)) {
                return /* () */0;
              } else if (step !== undefined) {
                var c = step;
                if (c[/* over */0]) {
                  Pervasives.invalid_arg(err_step_executed);
                } else if (m$1[/* snode */2][/* stamp */1][/* over */0]) {
                  m$1[/* snode */2][/* stamp */1] = c;
                } else {
                  Pervasives.invalid_arg("signal already scheduled on a step");
                }
                m$1[/* sv */0] = Caml_option.some(v);
                return add_deps(c, m$1[/* snode */2]);
              } else {
                var c$1 = create(/* () */0);
                m$1[/* snode */2][/* stamp */1] = c$1;
                m$1[/* sv */0] = Caml_option.some(v);
                add_deps(c$1, m$1[/* snode */2]);
                return execute$1(c$1);
              }
            })
        ];
}

function retain$1(s, c) {
  if (s.tag) {
    var m = s[0];
    var c$prime = m[/* snode */2][/* retain */2];
    m[/* snode */2][/* retain */2] = c;
    return /* `R */[
            82,
            c$prime
          ];
  } else {
    return Pervasives.invalid_arg("constant signals cannot retain a closure");
  }
}

function eq_fun(param) {
  if (param.tag) {
    return param[0][/* eq */1];
  }
  
}

function value$1(param) {
  if (param.tag) {
    var match = param[0][/* sv */0];
    if (match !== undefined) {
      return Caml_option.valFromOption(match);
    } else {
      return Pervasives.failwith("signal value undefined yet");
    }
  } else {
    return param[0];
  }
}

function stop$2(strong, param) {
  if (param.tag) {
    var m = param[0];
    var match = m[/* sv */0];
    if (match !== undefined) {
      return stop(strong, m[/* snode */2]);
    } else {
      var c = find_unfinished(Curry._1(m[/* snode */2][/* producers */3], /* () */0));
      if (c === nil) {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "React.re",
                1302,
                35
              ]
            ];
      }
      var stop$3 = function (param) {
        return stop(strong, m[/* snode */2]);
      };
      return add_eop(c, stop$3);
    }
  } else {
    return /* () */0;
  }
}

function equal$1($staropt$star, s, s$prime) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  if (s.tag) {
    if (s$prime.tag) {
      return s[0] === s$prime[0];
    } else {
      return false;
    }
  } else if (s$prime.tag) {
    return false;
  } else {
    return Curry._2(eq, s[0], s$prime[0]);
  }
}

function trace$1($staropt$star, t, s) {
  var iff = $staropt$star !== undefined ? $staropt$star : /* Const */Block.__(0, [true]);
  if (iff.tag) {
    var mc = iff[0];
    if (s.tag) {
      var m = s[0];
      var m$prime = smut(rsucc2(mc[/* snode */2], m[/* snode */2]), m[/* eq */1]);
      var p = function (param) {
        return /* :: */[
                mc[/* snode */2],
                /* :: */[
                  m[/* snode */2],
                  /* [] */0
                ]
              ];
      };
      var u = function (c) {
        var v = sval(m);
        var match = m$prime[/* sv */0];
        var exit = 0;
        if (match !== undefined && Curry._2(m$prime[/* eq */1], v, Caml_option.valFromOption(match))) {
          return /* () */0;
        } else {
          exit = 1;
        }
        if (exit === 1) {
          if (sval(mc)) {
            Curry._1(t, v);
          }
          return supdate(v, m$prime, c);
        }
        
      };
      scan_add(mc[/* snode */2][/* deps */5], m$prime[/* snode */2]);
      scan_add(m[/* snode */2][/* deps */5], m$prime[/* snode */2]);
      return signal(undefined, m$prime, p, u);
    } else {
      var v = s[0];
      var m$prime$1 = smut(rsucc(mc[/* snode */2]), Caml_obj.caml_equal);
      var p$1 = function (param) {
        return /* :: */[
                mc[/* snode */2],
                /* [] */0
              ];
      };
      var u$1 = function (c) {
        if (sval(mc)) {
          Curry._1(t, v);
        }
        rem(mc[/* snode */2][/* deps */5], m$prime$1[/* snode */2]);
        return stop(undefined, m$prime$1[/* snode */2]);
      };
      scan_add(mc[/* snode */2][/* deps */5], m$prime$1[/* snode */2]);
      return signal(Caml_option.some(v), m$prime$1, p$1, u$1);
    }
  } else if (iff[0]) {
    if (s.tag) {
      var m$1 = s[0];
      var m$prime$2 = smut(rsucc(m$1[/* snode */2]), m$1[/* eq */1]);
      var p$2 = function (param) {
        return /* :: */[
                m$1[/* snode */2],
                /* [] */0
              ];
      };
      var u$2 = function (c) {
        var v = sval(m$1);
        Curry._1(t, v);
        return supdate(v, m$prime$2, c);
      };
      scan_add(m$1[/* snode */2][/* deps */5], m$prime$2[/* snode */2]);
      return signal(undefined, m$prime$2, p$2, u$2);
    } else {
      Curry._1(t, s[0]);
      return s;
    }
  } else {
    return s;
  }
}

function hold($staropt$star, i, param) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  if (param) {
    var m = param[0];
    var m$prime = smut(rsucc(m[/* enode */1]), eq);
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* [] */0
            ];
    };
    var u = function (c) {
      var match = m[/* ev */0][0];
      if (match !== undefined) {
        return supdate(Caml_option.valFromOption(match), m$prime, c);
      } else {
        return /* () */0;
      }
    };
    add_dep(m, m$prime[/* snode */2]);
    return signal(Caml_option.some(i), m$prime, p, u);
  } else {
    return /* Const */Block.__(0, [i]);
  }
}

function map$1($staropt$star, f, param) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  if (param.tag) {
    var m = param[0];
    var m$prime = smut(rsucc(m[/* snode */2]), eq);
    var p = function (param) {
      return /* :: */[
              m[/* snode */2],
              /* [] */0
            ];
    };
    var u = function (c) {
      return supdate(Curry._1(f, sval(m)), m$prime, c);
    };
    scan_add(m[/* snode */2][/* deps */5], m$prime[/* snode */2]);
    return signal(undefined, m$prime, p, u);
  } else {
    return /* Const */Block.__(0, [Curry._1(f, param[0])]);
  }
}

function app$1($staropt$star, sf, sv) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  if (sf.tag) {
    var mf = sf[0];
    if (sv.tag) {
      var mv = sv[0];
      var m$prime = smut(rsucc2(mf[/* snode */2], mv[/* snode */2]), eq);
      var p = function (param) {
        return /* :: */[
                mf[/* snode */2],
                /* :: */[
                  mv[/* snode */2],
                  /* [] */0
                ]
              ];
      };
      var u = function (c) {
        return supdate(Curry._1(sval(mf), sval(mv)), m$prime, c);
      };
      scan_add(mf[/* snode */2][/* deps */5], m$prime[/* snode */2]);
      scan_add(mv[/* snode */2][/* deps */5], m$prime[/* snode */2]);
      return signal(undefined, m$prime, p, u);
    } else {
      var v = sv[0];
      var m$prime$1 = smut(rsucc(mf[/* snode */2]), eq);
      var p$1 = function (param) {
        return /* :: */[
                mf[/* snode */2],
                /* [] */0
              ];
      };
      var u$1 = function (c) {
        return supdate(Curry._1(sval(mf), v), m$prime$1, c);
      };
      scan_add(mf[/* snode */2][/* deps */5], m$prime$1[/* snode */2]);
      return signal(undefined, m$prime$1, p$1, u$1);
    }
  } else {
    var f = sf[0];
    if (sv.tag) {
      return map$1(eq, f, sv);
    } else {
      return /* Const */Block.__(0, [Curry._1(f, sv[0])]);
    }
  }
}

function filter$1($staropt$star, pred, i, s) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  if (s.tag) {
    var m = s[0];
    var m$prime = smut(rsucc(m[/* snode */2]), eq);
    var p = function (param) {
      return /* :: */[
              m[/* snode */2],
              /* [] */0
            ];
    };
    var u = function (c) {
      var v = sval(m);
      if (Curry._1(pred, v)) {
        return supdate(v, m$prime, c);
      } else {
        return /* () */0;
      }
    };
    scan_add(m[/* snode */2][/* deps */5], m$prime[/* snode */2]);
    return signal(Caml_option.some(i), m$prime, p, u);
  } else if (Curry._1(pred, s[0])) {
    return s;
  } else {
    return /* Const */Block.__(0, [i]);
  }
}

function fmap$1($staropt$star, fm, i, param) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  if (param.tag) {
    var m = param[0];
    var m$prime = smut(rsucc(m[/* snode */2]), eq);
    var p = function (param) {
      return /* :: */[
              m[/* snode */2],
              /* [] */0
            ];
    };
    var u = function (c) {
      var match = Curry._1(fm, sval(m));
      if (match !== undefined) {
        return supdate(Caml_option.valFromOption(match), m$prime, c);
      } else {
        return /* () */0;
      }
    };
    scan_add(m[/* snode */2][/* deps */5], m$prime[/* snode */2]);
    return signal(Caml_option.some(i), m$prime, p, u);
  } else {
    var match = Curry._1(fm, param[0]);
    if (match !== undefined) {
      return /* Const */Block.__(0, [Caml_option.valFromOption(match)]);
    } else {
      return /* Const */Block.__(0, [i]);
    }
  }
}

function diff$1(d, param) {
  if (param.tag) {
    var m = param[0];
    var m$prime = emut(rsucc(m[/* snode */2]));
    var last = /* record */[/* contents */undefined];
    var p = function (param) {
      return /* :: */[
              m[/* snode */2],
              /* [] */0
            ];
    };
    var u = function (c) {
      var v = sval(m);
      var match = last[0];
      if (match !== undefined) {
        last[0] = Caml_option.some(v);
        return eupdate(Curry._2(d, v, Caml_option.valFromOption(match)), m$prime, c);
      } else {
        throw [
              Caml_builtin_exceptions.assert_failure,
              /* tuple */[
                "React.re",
                1460,
                20
              ]
            ];
      }
    };
    var post_add_op = function (param) {
      last[0] = Caml_option.some(sval(m));
      return /* () */0;
    };
    end_of_step_add_dep(post_add_op, true, m, m$prime);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function changes$1(param) {
  if (param.tag) {
    var m = param[0];
    var m$prime = emut(rsucc(m[/* snode */2]));
    var p = function (param) {
      return /* :: */[
              m[/* snode */2],
              /* [] */0
            ];
    };
    var u = function (c) {
      return eupdate(sval(m), m$prime, c);
    };
    end_of_step_add_dep(undefined, true, m, m$prime);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function sample(f, e, param) {
  if (param.tag) {
    if (e) {
      var me = e[0];
      var ms = param[0];
      var m$prime = emut(rsucc2(me[/* enode */1], ms[/* snode */2]));
      var p = function (param) {
        return /* :: */[
                me[/* enode */1],
                /* :: */[
                  ms[/* snode */2],
                  /* [] */0
                ]
              ];
      };
      var u = function (c) {
        var match = me[/* ev */0][0];
        if (match !== undefined) {
          return eupdate(Curry._2(f, Caml_option.valFromOption(match), sval(ms)), m$prime, c);
        } else {
          return /* () */0;
        }
      };
      add_dep(me, m$prime[/* enode */1]);
      scan_add(ms[/* snode */2][/* deps */5], m$prime[/* enode */1]);
      return $$event(m$prime, p, u);
    } else {
      return /* Never */0;
    }
  } else {
    var v = param[0];
    return map((function (ev) {
                  return Curry._2(f, ev, v);
                }), e);
  }
}

function on$1($staropt$star, c, i, s) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  if (c.tag) {
    var mc = c[0];
    if (s.tag) {
      var ms = s[0];
      var m$prime = smut(rsucc2(mc[/* snode */2], ms[/* snode */2]), eq);
      var p = function (param) {
        return /* :: */[
                mc[/* snode */2],
                /* :: */[
                  ms[/* snode */2],
                  /* [] */0
                ]
              ];
      };
      var u = function (c) {
        if (sval(mc)) {
          return supdate(sval(ms), m$prime, c);
        } else {
          return /* () */0;
        }
      };
      scan_add(mc[/* snode */2][/* deps */5], m$prime[/* snode */2]);
      scan_add(ms[/* snode */2][/* deps */5], m$prime[/* snode */2]);
      return signal(Caml_option.some(i), m$prime, p, u);
    } else {
      var v = s[0];
      var m$prime$1 = smut(rsucc(mc[/* snode */2]), eq);
      var p$1 = function (param) {
        return /* :: */[
                mc[/* snode */2],
                /* [] */0
              ];
      };
      var u$1 = function (c) {
        if (sval(mc)) {
          return supdate(v, m$prime$1, c);
        } else {
          return /* () */0;
        }
      };
      scan_add(mc[/* snode */2][/* deps */5], m$prime$1[/* snode */2]);
      return signal(Caml_option.some(i), m$prime$1, p$1, u$1);
    }
  } else if (c[0]) {
    return s;
  } else {
    return /* Const */Block.__(0, [i]);
  }
}

function dismiss$1($staropt$star, c, i, s) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  if (c) {
    var mc = c[0];
    if (s.tag) {
      var ms = s[0];
      var m$prime = smut(rsucc2(mc[/* enode */1], ms[/* snode */2]), eq);
      var p = function (param) {
        return /* :: */[
                mc[/* enode */1],
                /* :: */[
                  ms[/* snode */2],
                  /* [] */0
                ]
              ];
      };
      var u = function (c) {
        var match = mc[/* ev */0][0];
        if (match !== undefined) {
          return /* () */0;
        } else {
          return supdate(sval(ms), m$prime, c);
        }
      };
      scan_add(mc[/* enode */1][/* deps */5], m$prime[/* snode */2]);
      scan_add(ms[/* snode */2][/* deps */5], m$prime[/* snode */2]);
      return signal(Caml_option.some(i), m$prime, p, u);
    } else {
      var v = s[0];
      var m$prime$1 = smut(rsucc(mc[/* enode */1]), eq);
      var p$1 = function (param) {
        return /* :: */[
                mc[/* enode */1],
                /* [] */0
              ];
      };
      var u$1 = function (c) {
        var match = mc[/* ev */0][0];
        if (match !== undefined) {
          return /* () */0;
        } else {
          return supdate(v, m$prime$1, c);
        }
      };
      scan_add(mc[/* enode */1][/* deps */5], m$prime$1[/* snode */2]);
      return signal(Caml_option.some(i), m$prime$1, p$1, u$1);
    }
  } else {
    return s;
  }
}

function accum$1($staropt$star, ef, i) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  if (ef) {
    var m = ef[0];
    var m$prime = smut(rsucc(m[/* enode */1]), eq);
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* [] */0
            ];
    };
    var u = function (c) {
      var match = m[/* ev */0][0];
      if (match !== undefined) {
        return supdate(Curry._1(match, sval(m$prime)), m$prime, c);
      } else {
        return /* () */0;
      }
    };
    add_dep(m, m$prime[/* snode */2]);
    return signal(Caml_option.some(i), m$prime, p, u);
  } else {
    return /* Const */Block.__(0, [i]);
  }
}

function fold$2($staropt$star, f, i, param) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  if (param) {
    var m = param[0];
    var m$prime = smut(rsucc(m[/* enode */1]), eq);
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* [] */0
            ];
    };
    var u = function (c) {
      var match = m[/* ev */0][0];
      if (match !== undefined) {
        return supdate(Curry._2(f, sval(m$prime), Caml_option.valFromOption(match)), m$prime, c);
      } else {
        return /* () */0;
      }
    };
    add_dep(m, m$prime[/* snode */2]);
    return signal(Caml_option.some(i), m$prime, p, u);
  } else {
    return /* Const */Block.__(0, [i]);
  }
}

function merge$1($staropt$star, f, a, sl) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  var rmax$prime = function (acc, param) {
    if (param.tag) {
      return rmax(acc, param[0][/* snode */2]);
    } else {
      return acc;
    }
  };
  var nodes = function (acc, param) {
    if (param.tag) {
      return /* :: */[
              param[0][/* snode */2],
              acc
            ];
    } else {
      return acc;
    }
  };
  var m$prime = smut(rsucc(List.fold_left(rmax$prime, rmin, sl)), eq);
  var p = function (param) {
    return List.fold_left(nodes, /* [] */0, sl);
  };
  var u = function (c) {
    return supdate(List.fold_left((function (param, param$1) {
                      var f$1 = f;
                      var a = param;
                      var param$2 = param$1;
                      if (param$2.tag) {
                        return Curry._2(f$1, a, sval(param$2[0]));
                      } else {
                        return Curry._2(f$1, a, param$2[0]);
                      }
                    }), a, sl), m$prime, c);
  };
  var dep = function (param) {
    if (param.tag) {
      return scan_add(param[0][/* snode */2][/* deps */5], m$prime[/* snode */2]);
    } else {
      return /* () */0;
    }
  };
  List.iter(dep, sl);
  return signal(undefined, m$prime, p, u);
}

function $$switch$1($staropt$star, param) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  if (param.tag) {
    var mss = param[0];
    var dummy = smut(Pervasives.min_int, eq);
    var src = /* record */[/* contents : Smut */Block.__(1, [dummy])];
    var m$prime = smut(rsucc(mss[/* snode */2]), eq);
    var p = function (param) {
      var match = src[0];
      if (match.tag) {
        return /* :: */[
                mss[/* snode */2],
                /* :: */[
                  match[0][/* snode */2],
                  /* [] */0
                ]
              ];
      } else {
        return /* :: */[
                mss[/* snode */2],
                /* [] */0
              ];
      }
    };
    var u = function (c) {
      if (sval(mss) === src[0]) {
        var match = src[0];
        if (match.tag) {
          return supdate(sval(match[0]), m$prime, c);
        } else {
          return /* () */0;
        }
      } else {
        var match$1 = src[0];
        if (match$1.tag) {
          rem(match$1[0][/* snode */2][/* deps */5], m$prime[/* snode */2]);
        }
        var new_src = sval(mss);
        src[0] = new_src;
        if (new_src.tag) {
          var m = new_src[0];
          scan_add(m[/* snode */2][/* deps */5], m$prime[/* snode */2]);
          if (c === nil) {
            update_rank(m$prime[/* snode */2], rsucc2(m[/* snode */2], mss[/* snode */2]));
            var c$1 = find_unfinished(/* :: */[
                  m[/* snode */2],
                  /* [] */0
                ]);
            if (c$1 === nil) {
              return supdate(sval(m), m$prime, c$1);
            } else {
              return add$1(c$1, m$prime[/* snode */2]);
            }
          } else if (update_rank(m$prime[/* snode */2], rsucc2(m[/* snode */2], mss[/* snode */2]))) {
            m$prime[/* snode */2][/* stamp */1] = nil;
            rebuild(c[/* heap */1]);
            return add$1(c, m$prime[/* snode */2]);
          } else {
            return supdate(sval(m), m$prime, c);
          }
        } else {
          update_rank(m$prime[/* snode */2], rsucc(mss[/* snode */2]));
          return supdate(new_src[0], m$prime, c);
        }
      }
    };
    scan_add(mss[/* snode */2][/* deps */5], m$prime[/* snode */2]);
    scan_add(dummy[/* snode */2][/* deps */5], m$prime[/* snode */2]);
    return signal(undefined, m$prime, p, u);
  } else {
    return param[0];
  }
}

function bind$1(eq, s, sf) {
  return $$switch$1(eq, map$1((function (prim, prim$1) {
                    return prim === prim$1;
                  }), sf, s));
}

function fix$1($staropt$star, i, f) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  var update_delayed = function (n, p, u, nl) {
    bind(n, p, u);
    var c = find_unfinished(nl);
    if (c === nil) {
      var c$1 = create(/* () */0);
      Curry._1(n[/* update */4], c$1);
      return execute$1(c$1);
    } else {
      return add$1(c, n);
    }
  };
  var m = smut(Pervasives.max_int, eq);
  var s = signal(Caml_option.some(i), m, (function (param) {
          return /* [] */0;
        }), (function (param) {
          return /* () */0;
        }));
  var match = Curry._1(f, s);
  var match$1 = match[0];
  if (match$1.tag) {
    var m$prime = match$1[0];
    if (m$prime[/* snode */2][/* rank */0] === Pervasives.max_int) {
      Pervasives.invalid_arg(err_fix);
    }
    var p = function (param) {
      return /* [] */0;
    };
    var u = function (c) {
      return supdate(sval(m$prime), m, c);
    };
    scan_add(m$prime[/* snode */2][/* deps */5], m[/* snode */2]);
    update_delayed(m[/* snode */2], p, u, /* :: */[
          m$prime[/* snode */2],
          deps(m[/* snode */2])
        ]);
    return match[1];
  } else {
    var v = match$1[0];
    var p$1 = function (param) {
      return /* [] */0;
    };
    var u$1 = function (c) {
      return supdate(v, m, c);
    };
    update_delayed(m[/* snode */2], p$1, u$1, deps(m[/* snode */2]));
    return match[1];
  }
}

function l2$1($staropt$star, f, s, s$prime) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  if (s.tag) {
    var m0 = s[0];
    if (s$prime.tag) {
      var m1 = s$prime[0];
      var m$prime = smut(rsucc2(m0[/* snode */2], m1[/* snode */2]), eq);
      var p = function (param) {
        return /* :: */[
                m0[/* snode */2],
                /* :: */[
                  m1[/* snode */2],
                  /* [] */0
                ]
              ];
      };
      var u = function (c) {
        return supdate(Curry._2(f, sval(m0), sval(m1)), m$prime, c);
      };
      scan_add(m0[/* snode */2][/* deps */5], m$prime[/* snode */2]);
      scan_add(m1[/* snode */2][/* deps */5], m$prime[/* snode */2]);
      return signal(undefined, m$prime, p, u);
    } else {
      var v = s$prime[0];
      var m$prime$1 = smut(rsucc(m0[/* snode */2]), eq);
      var p$1 = function (param) {
        return /* :: */[
                m0[/* snode */2],
                /* [] */0
              ];
      };
      var u$1 = function (c) {
        return supdate(Curry._2(f, sval(m0), v), m$prime$1, c);
      };
      scan_add(m0[/* snode */2][/* deps */5], m$prime$1[/* snode */2]);
      return signal(undefined, m$prime$1, p$1, u$1);
    }
  } else {
    var v$1 = s[0];
    if (s$prime.tag) {
      var m = s$prime[0];
      var m$prime$2 = smut(rsucc(m[/* snode */2]), eq);
      var p$2 = function (param) {
        return /* :: */[
                m[/* snode */2],
                /* [] */0
              ];
      };
      var u$2 = function (c) {
        return supdate(Curry._2(f, v$1, sval(m)), m$prime$2, c);
      };
      scan_add(m[/* snode */2][/* deps */5], m$prime$2[/* snode */2]);
      return signal(undefined, m$prime$2, p$2, u$2);
    } else {
      return /* Const */Block.__(0, [Curry._2(f, v$1, s$prime[0])]);
    }
  }
}

function l3$1($staropt$star, f, s0, s1, s2) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  var exit = 0;
  if (s0.tag) {
    var m0 = s0[0];
    if (s1.tag) {
      var m1 = s1[0];
      if (s2.tag) {
        var m2 = s2[0];
        var r = rsucc(rmax(rmax(m0[/* snode */2], m1[/* snode */2]), m2[/* snode */2]));
        var m$prime = smut(r, eq);
        var p = function (param) {
          return /* :: */[
                  m0[/* snode */2],
                  /* :: */[
                    m1[/* snode */2],
                    /* :: */[
                      m2[/* snode */2],
                      /* [] */0
                    ]
                  ]
                ];
        };
        var u = function (c) {
          return supdate(Curry._3(f, sval(m0), sval(m1), sval(m2)), m$prime, c);
        };
        scan_add(m0[/* snode */2][/* deps */5], m$prime[/* snode */2]);
        scan_add(m1[/* snode */2][/* deps */5], m$prime[/* snode */2]);
        scan_add(m2[/* snode */2][/* deps */5], m$prime[/* snode */2]);
        return signal(undefined, m$prime, p, u);
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else if (s1.tag || s2.tag) {
    exit = 1;
  } else {
    return /* Const */Block.__(0, [Curry._3(f, s0[0], s1[0], s2[0])]);
  }
  if (exit === 1) {
    return app$1(eq, l2$1((function (prim, prim$1) {
                      return prim === prim$1;
                    }), f, s0, s1), s2);
  }
  
}

function l4$1($staropt$star, f, s0, s1, s2, s3) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  var exit = 0;
  if (s0.tag) {
    var m0 = s0[0];
    if (s1.tag) {
      var m1 = s1[0];
      if (s2.tag) {
        var m2 = s2[0];
        if (s3.tag) {
          var m3 = s3[0];
          var r = rsucc(rmax(rmax(m0[/* snode */2], m1[/* snode */2]), rmax(m2[/* snode */2], m3[/* snode */2])));
          var m$prime = smut(r, eq);
          var p = function (param) {
            return /* :: */[
                    m0[/* snode */2],
                    /* :: */[
                      m1[/* snode */2],
                      /* :: */[
                        m2[/* snode */2],
                        /* :: */[
                          m3[/* snode */2],
                          /* [] */0
                        ]
                      ]
                    ]
                  ];
          };
          var u = function (c) {
            return supdate(Curry._4(f, sval(m0), sval(m1), sval(m2), sval(m3)), m$prime, c);
          };
          scan_add(m0[/* snode */2][/* deps */5], m$prime[/* snode */2]);
          scan_add(m1[/* snode */2][/* deps */5], m$prime[/* snode */2]);
          scan_add(m2[/* snode */2][/* deps */5], m$prime[/* snode */2]);
          scan_add(m3[/* snode */2][/* deps */5], m$prime[/* snode */2]);
          return signal(undefined, m$prime, p, u);
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else if (s1.tag || s2.tag || s3.tag) {
    exit = 1;
  } else {
    return /* Const */Block.__(0, [Curry._4(f, s0[0], s1[0], s2[0], s3[0])]);
  }
  if (exit === 1) {
    return app$1(eq, l3$1((function (prim, prim$1) {
                      return prim === prim$1;
                    }), f, s0, s1, s2), s3);
  }
  
}

function l5$1($staropt$star, f, s0, s1, s2, s3, s4) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  var exit = 0;
  if (s0.tag) {
    var m0 = s0[0];
    if (s1.tag) {
      var m1 = s1[0];
      if (s2.tag) {
        var m2 = s2[0];
        if (s3.tag) {
          var m3 = s3[0];
          if (s4.tag) {
            var m4 = s4[0];
            var r = rsucc(rmax(rmax(m0[/* snode */2], m1[/* snode */2]), rmax(m2[/* snode */2], rmax(m3[/* snode */2], m4[/* snode */2]))));
            var m$prime = smut(r, eq);
            var p = function (param) {
              return /* :: */[
                      m0[/* snode */2],
                      /* :: */[
                        m1[/* snode */2],
                        /* :: */[
                          m2[/* snode */2],
                          /* :: */[
                            m3[/* snode */2],
                            /* :: */[
                              m4[/* snode */2],
                              /* [] */0
                            ]
                          ]
                        ]
                      ]
                    ];
            };
            var u = function (c) {
              var v = Curry._5(f, sval(m0), sval(m1), sval(m2), sval(m3), sval(m4));
              return supdate(v, m$prime, c);
            };
            scan_add(m0[/* snode */2][/* deps */5], m$prime[/* snode */2]);
            scan_add(m1[/* snode */2][/* deps */5], m$prime[/* snode */2]);
            scan_add(m2[/* snode */2][/* deps */5], m$prime[/* snode */2]);
            scan_add(m3[/* snode */2][/* deps */5], m$prime[/* snode */2]);
            scan_add(m4[/* snode */2][/* deps */5], m$prime[/* snode */2]);
            return signal(undefined, m$prime, p, u);
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else if (s1.tag || s2.tag || s3.tag || s4.tag) {
    exit = 1;
  } else {
    return /* Const */Block.__(0, [Curry._5(f, s0[0], s1[0], s2[0], s3[0], s4[0])]);
  }
  if (exit === 1) {
    return app$1(eq, l4$1((function (prim, prim$1) {
                      return prim === prim$1;
                    }), f, s0, s1, s2, s3), s4);
  }
  
}

function l6$1($staropt$star, f, s0, s1, s2, s3, s4, s5) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  var exit = 0;
  if (s0.tag) {
    var m0 = s0[0];
    if (s1.tag) {
      var m1 = s1[0];
      if (s2.tag) {
        var m2 = s2[0];
        if (s3.tag) {
          var m3 = s3[0];
          if (s4.tag) {
            var m4 = s4[0];
            if (s5.tag) {
              var m5 = s5[0];
              var m = rmax(rmax(m0[/* snode */2], rmax(m1[/* snode */2], m2[/* snode */2])), rmax(m3[/* snode */2], rmax(m4[/* snode */2], m5[/* snode */2])));
              var m$prime = smut(rsucc(m), eq);
              var p = function (param) {
                return /* :: */[
                        m0[/* snode */2],
                        /* :: */[
                          m1[/* snode */2],
                          /* :: */[
                            m2[/* snode */2],
                            /* :: */[
                              m3[/* snode */2],
                              /* :: */[
                                m4[/* snode */2],
                                /* :: */[
                                  m5[/* snode */2],
                                  /* [] */0
                                ]
                              ]
                            ]
                          ]
                        ]
                      ];
              };
              var u = function (c) {
                var v = Curry._6(f, sval(m0), sval(m1), sval(m2), sval(m3), sval(m4), sval(m5));
                return supdate(v, m$prime, c);
              };
              scan_add(m0[/* snode */2][/* deps */5], m$prime[/* snode */2]);
              scan_add(m1[/* snode */2][/* deps */5], m$prime[/* snode */2]);
              scan_add(m2[/* snode */2][/* deps */5], m$prime[/* snode */2]);
              scan_add(m3[/* snode */2][/* deps */5], m$prime[/* snode */2]);
              scan_add(m4[/* snode */2][/* deps */5], m$prime[/* snode */2]);
              scan_add(m5[/* snode */2][/* deps */5], m$prime[/* snode */2]);
              return signal(undefined, m$prime, p, u);
            } else {
              exit = 1;
            }
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
      } else {
        exit = 1;
      }
    } else {
      exit = 1;
    }
  } else if (s1.tag || s2.tag || s3.tag || s4.tag || s5.tag) {
    exit = 1;
  } else {
    return /* Const */Block.__(0, [Curry._6(f, s0[0], s1[0], s2[0], s3[0], s4[0], s5[0])]);
  }
  if (exit === 1) {
    return app$1(eq, l5$1((function (prim, prim$1) {
                      return prim === prim$1;
                    }), f, s0, s1, s2, s3, s4), s5);
  }
  
}

var eq = Caml_obj.caml_equal;

function not(s) {
  return map$1(eq, (function (prim) {
                return !prim;
              }), s);
}

function $unknown$unknown(s, s$prime) {
  return l2$1(eq, (function (prim, prim$1) {
                if (prim) {
                  return prim$1;
                } else {
                  return false;
                }
              }), s, s$prime);
}

function $pipe$pipe(s, s$prime) {
  return l2$1(eq, (function (prim, prim$1) {
                if (prim) {
                  return true;
                } else {
                  return prim$1;
                }
              }), s, s$prime);
}

var edge = changes$1;

function edge_detect(edge, param) {
  if (param.tag) {
    var m = param[0];
    var m$prime = emut(rsucc(m[/* snode */2]));
    var p = function (param) {
      return /* :: */[
              m[/* snode */2],
              /* [] */0
            ];
    };
    var u = function (c) {
      if (Caml_obj.caml_equal(sval(m), edge)) {
        return eupdate(/* () */0, m$prime, c);
      } else {
        return 0;
      }
    };
    end_of_step_add_dep(undefined, true, m, m$prime);
    return $$event(m$prime, p, u);
  } else {
    return /* Never */0;
  }
}

function rise(s) {
  return edge_detect(true, s);
}

function fall(s) {
  return edge_detect(false, s);
}

function flip(b, param) {
  if (param) {
    var m = param[0];
    var m$prime = smut(rsucc(m[/* enode */1]), Caml_obj.caml_equal);
    var p = function (param) {
      return /* :: */[
              m[/* enode */1],
              /* [] */0
            ];
    };
    var u = function (c) {
      var match = m[/* ev */0][0];
      if (match !== undefined) {
        return supdate(!sval(m$prime), m$prime, c);
      } else {
        return /* () */0;
      }
    };
    add_dep(m, m$prime[/* snode */2]);
    return signal(b, m$prime, p, u);
  } else {
    return /* Const */Block.__(0, [b]);
  }
}

var eq$1 = Caml_obj.caml_equal;

function $tilde$neg(s) {
  return map$1(eq$1, (function (prim) {
                return -prim | 0;
              }), s);
}

function succ(s) {
  return map$1(eq$1, (function (prim) {
                return prim + 1 | 0;
              }), s);
}

function pred(s) {
  return map$1(eq$1, (function (prim) {
                return prim - 1 | 0;
              }), s);
}

function $plus(s, s$prime) {
  return l2$1(eq$1, (function (prim, prim$1) {
                return prim + prim$1 | 0;
              }), s, s$prime);
}

function $neg(s, s$prime) {
  return l2$1(eq$1, (function (prim, prim$1) {
                return prim - prim$1 | 0;
              }), s, s$prime);
}

function $star(s, s$prime) {
  return l2$1(eq$1, Caml_int32.imul, s, s$prime);
}

function mod(s, s$prime) {
  return l2$1(eq$1, Caml_int32.mod_, s, s$prime);
}

function abs(s) {
  return map$1(eq$1, Pervasives.abs, s);
}

var max_int = /* Const */Block.__(0, [Pervasives.max_int]);

var min_int = /* Const */Block.__(0, [Pervasives.min_int]);

function land(s, s$prime) {
  return l2$1(eq$1, (function (prim, prim$1) {
                return prim & prim$1;
              }), s, s$prime);
}

function lor(s, s$prime) {
  return l2$1(eq$1, (function (prim, prim$1) {
                return prim | prim$1;
              }), s, s$prime);
}

function lxor(s, s$prime) {
  return l2$1(eq$1, (function (prim, prim$1) {
                return prim ^ prim$1;
              }), s, s$prime);
}

function lnot(s) {
  return map$1(eq$1, Pervasives.lnot, s);
}

function lsl(s, s$prime) {
  return l2$1(eq$1, (function (prim, prim$1) {
                return (prim << prim$1);
              }), s, s$prime);
}

function lsr(s, s$prime) {
  return l2$1(eq$1, (function (prim, prim$1) {
                return (prim >>> prim$1) | 0;
              }), s, s$prime);
}

function asr(s, s$prime) {
  return l2$1(eq$1, (function (prim, prim$1) {
                return (prim >> prim$1);
              }), s, s$prime);
}

var eq$2 = Caml_obj.caml_equal;

function $tilde$neg$dot(s) {
  return map$1(eq$2, (function (prim) {
                return -prim;
              }), s);
}

function $plus$dot(s, s$prime) {
  return l2$1(eq$2, (function (prim, prim$1) {
                return prim + prim$1;
              }), s, s$prime);
}

function $neg$dot(s, s$prime) {
  return l2$1(eq$2, (function (prim, prim$1) {
                return prim - prim$1;
              }), s, s$prime);
}

function $star$dot(s, s$prime) {
  return l2$1(eq$2, (function (prim, prim$1) {
                return prim * prim$1;
              }), s, s$prime);
}

function $slash$dot(s, s$prime) {
  return l2$1(eq$2, (function (prim, prim$1) {
                return prim / prim$1;
              }), s, s$prime);
}

function $star$star(s, s$prime) {
  return l2$1(eq$2, (function (prim, prim$1) {
                return Math.pow(prim, prim$1);
              }), s, s$prime);
}

function sqrt(s) {
  return map$1(eq$2, (function (prim) {
                return Math.sqrt(prim);
              }), s);
}

function exp(s) {
  return map$1(eq$2, (function (prim) {
                return Math.exp(prim);
              }), s);
}

function log(s) {
  return map$1(eq$2, (function (prim) {
                return Math.log(prim);
              }), s);
}

function log10(s) {
  return map$1(eq$2, (function (prim) {
                return Math.log10(prim);
              }), s);
}

function cos(s) {
  return map$1(eq$2, (function (prim) {
                return Math.cos(prim);
              }), s);
}

function sin(s) {
  return map$1(eq$2, (function (prim) {
                return Math.sin(prim);
              }), s);
}

function tan(s) {
  return map$1(eq$2, (function (prim) {
                return Math.tan(prim);
              }), s);
}

function acos(s) {
  return map$1(eq$2, (function (prim) {
                return Math.acos(prim);
              }), s);
}

function asin(s) {
  return map$1(eq$2, (function (prim) {
                return Math.asin(prim);
              }), s);
}

function atan(s) {
  return map$1(eq$2, (function (prim) {
                return Math.atan(prim);
              }), s);
}

function atan2(s, s$prime) {
  return l2$1(eq$2, (function (prim, prim$1) {
                return Math.atan2(prim, prim$1);
              }), s, s$prime);
}

function cosh(s) {
  return map$1(eq$2, (function (prim) {
                return Math.cosh(prim);
              }), s);
}

function sinh(s) {
  return map$1(eq$2, (function (prim) {
                return Math.sinh(prim);
              }), s);
}

function tanh(s) {
  return map$1(eq$2, (function (prim) {
                return Math.tanh(prim);
              }), s);
}

function ceil(s) {
  return map$1(eq$2, (function (prim) {
                return Math.ceil(prim);
              }), s);
}

function floor(s) {
  return map$1(eq$2, (function (prim) {
                return Math.floor(prim);
              }), s);
}

function abs_float(s) {
  return map$1(eq$2, (function (prim) {
                return Math.abs(prim);
              }), s);
}

function mod_float(s, s$prime) {
  return l2$1(eq$2, (function (prim, prim$1) {
                return prim % prim$1;
              }), s, s$prime);
}

function frexp(s) {
  return map$1(Caml_obj.caml_equal, Caml_float.caml_frexp_float, s);
}

function ldexp(s, s$prime) {
  return l2$1(eq$2, Caml_float.caml_ldexp_float, s, s$prime);
}

function modf(s) {
  return map$1(Caml_obj.caml_equal, Caml_float.caml_modf_float, s);
}

function $$float(s) {
  return map$1(eq$2, (function (prim) {
                return prim;
              }), s);
}

function float_of_int(s) {
  return map$1(eq$2, (function (prim) {
                return prim;
              }), s);
}

function truncate(s) {
  return map$1(eq$1, (function (prim) {
                return prim | 0;
              }), s);
}

function int_of_float(s) {
  return map$1(eq$1, (function (prim) {
                return prim | 0;
              }), s);
}

var infinity = /* Const */Block.__(0, [Number.POSITIVE_INFINITY]);

var neg_infinity = /* Const */Block.__(0, [Number.NEGATIVE_INFINITY]);

var nan = /* Const */Block.__(0, [Number.NaN]);

var max_float = /* Const */Block.__(0, [Number.MAX_VALUE]);

var min_float = /* Const */Block.__(0, [Number.MIN_VALUE]);

var epsilon_float = /* Const */Block.__(0, [Pervasives.epsilon_float]);

function classify_float(s) {
  return map$1(Caml_obj.caml_equal, Pervasives.classify_float, s);
}

function pair(eq, s, s$prime) {
  return l2$1(eq, (function (x, y) {
                return /* tuple */[
                        x,
                        y
                      ];
              }), s, s$prime);
}

function fst(eq, s) {
  return map$1(eq, (function (prim) {
                return prim[0];
              }), s);
}

function snd(eq, s) {
  return map$1(eq, (function (prim) {
                return prim[1];
              }), s);
}

var Pair = /* module */[
  /* pair */pair,
  /* fst */fst,
  /* snd */snd
];

function some$1(s) {
  var match = eq_fun(s);
  var eq;
  if (match !== undefined) {
    var eq$1 = match;
    eq = (function (v, v$prime) {
        if (v !== undefined) {
          if (v$prime !== undefined) {
            return Curry._2(eq$1, Caml_option.valFromOption(v), Caml_option.valFromOption(v$prime));
          } else {
            throw [
                  Caml_builtin_exceptions.assert_failure,
                  /* tuple */[
                    "React.re",
                    1916,
                    19
                  ]
                ];
          }
        } else {
          throw [
                Caml_builtin_exceptions.assert_failure,
                /* tuple */[
                  "React.re",
                  1916,
                  19
                ]
              ];
        }
      });
  } else {
    eq = undefined;
  }
  return map$1(eq, (function (v) {
                return Caml_option.some(v);
              }), s);
}

function value$2($staropt$star, $$default, s) {
  var eq = $staropt$star !== undefined ? $staropt$star : Caml_obj.caml_equal;
  if (s.tag) {
    var m = s[0];
    if ($$default[0] >= 815032112) {
      var match = $$default[1];
      if (match.tag) {
        var md = match[0];
        var c = find_unfinished(/* :: */[
              md[/* snode */2],
              /* [] */0
            ]);
        if (c === nil) {
          var m$prime = smut(rsucc(m[/* snode */2]), eq);
          var p = function (param) {
            return /* :: */[
                    m[/* snode */2],
                    /* [] */0
                  ];
          };
          var u = function (c) {
            var match = sval(m);
            if (match !== undefined) {
              return supdate(Caml_option.valFromOption(match), m$prime, c);
            } else {
              return /* () */0;
            }
          };
          scan_add(m[/* snode */2][/* deps */5], m$prime[/* snode */2]);
          return signal(Caml_option.some(sval(md)), m$prime, p, u);
        } else {
          var m$prime$1 = smut(rsucc2(m[/* snode */2], md[/* snode */2]), eq);
          var p$1 = function (param) {
            return /* :: */[
                    m[/* snode */2],
                    /* [] */0
                  ];
          };
          var u$1 = function (c) {
            var match = sval(m);
            if (match !== undefined) {
              return supdate(Caml_option.valFromOption(match), m$prime$1, c);
            } else {
              return /* () */0;
            }
          };
          var p_first = function (param) {
            return /* :: */[
                    m[/* snode */2],
                    /* :: */[
                      md[/* snode */2],
                      /* [] */0
                    ]
                  ];
          };
          var u_first = function (c) {
            rem(md[/* snode */2][/* deps */5], m$prime$1[/* snode */2]);
            var match = sval(m);
            if (match !== undefined) {
              supdate(Caml_option.valFromOption(match), m$prime$1, c);
            } else {
              supdate(sval(md), m$prime$1, c);
            }
            return bind(m$prime$1[/* snode */2], p$1, u$1);
          };
          scan_add(m[/* snode */2][/* deps */5], m$prime$1[/* snode */2]);
          scan_add(md[/* snode */2][/* deps */5], m$prime$1[/* snode */2]);
          return signal(undefined, m$prime$1, p_first, u_first);
        }
      } else {
        return fmap$1(eq, (function (v) {
                      return v;
                    }), match[0], s);
      }
    } else {
      var match$1 = $$default[1];
      if (match$1.tag) {
        var md$1 = match$1[0];
        var m$prime$2 = smut(rsucc2(m[/* snode */2], md$1[/* snode */2]), eq);
        var p$2 = function (param) {
          return /* :: */[
                  m[/* snode */2],
                  /* :: */[
                    md$1[/* snode */2],
                    /* [] */0
                  ]
                ];
        };
        var u$2 = function (c) {
          var match = sval(m);
          if (match !== undefined) {
            return supdate(Caml_option.valFromOption(match), m$prime$2, c);
          } else {
            return supdate(sval(md$1), m$prime$2, c);
          }
        };
        scan_add(m[/* snode */2][/* deps */5], m$prime$2[/* snode */2]);
        scan_add(md$1[/* snode */2][/* deps */5], m$prime$2[/* snode */2]);
        return signal(undefined, m$prime$2, p$2, u$2);
      } else {
        var d = match$1[0];
        return map$1(eq, (function (param) {
                      if (param !== undefined) {
                        return Caml_option.valFromOption(param);
                      } else {
                        return d;
                      }
                    }), s);
      }
    }
  } else {
    var match$2 = s[0];
    if (match$2 !== undefined) {
      return /* Const */Block.__(0, [Caml_option.valFromOption(match$2)]);
    } else if ($$default[0] >= 815032112) {
      var d$1 = $$default[1];
      if (d$1.tag) {
        var md$2 = d$1[0];
        var c$1 = find_unfinished(/* :: */[
              md$2[/* snode */2],
              /* [] */0
            ]);
        if (c$1 === nil) {
          return /* Const */Block.__(0, [sval(md$2)]);
        } else {
          var m$prime$3 = smut(rsucc(md$2[/* snode */2]), eq);
          var p$3 = function (param) {
            return /* :: */[
                    md$2[/* snode */2],
                    /* [] */0
                  ];
          };
          var u$3 = function (c) {
            rem(md$2[/* snode */2][/* deps */5], m$prime$3[/* snode */2]);
            supdate(sval(md$2), m$prime$3, c);
            return stop(undefined, m$prime$3[/* snode */2]);
          };
          scan_add(md$2[/* snode */2][/* deps */5], m$prime$3[/* snode */2]);
          return signal(undefined, m$prime$3, p$3, u$3);
        }
      } else {
        return /* Const */Block.__(0, [d$1[0]]);
      }
    } else {
      return $$default[1];
    }
  }
}

var Option_000 = /* none : Const */Block.__(0, [undefined]);

var $$Option$1 = /* module */[
  Option_000,
  /* some */some$1,
  /* value */value$2
];

function $eq(s, s$prime) {
  return l2$1(eq, Caml_obj.caml_equal, s, s$prime);
}

function $less$great(s, s$prime) {
  return l2$1(eq, Caml_obj.caml_notequal, s, s$prime);
}

function $less(s, s$prime) {
  return l2$1(eq, Caml_obj.caml_lessthan, s, s$prime);
}

function $great(s, s$prime) {
  return l2$1(eq, Caml_obj.caml_greaterthan, s, s$prime);
}

function $less$eq(s, s$prime) {
  return l2$1(eq, Caml_obj.caml_lessequal, s, s$prime);
}

function $great$eq(s, s$prime) {
  return l2$1(eq, Caml_obj.caml_greaterequal, s, s$prime);
}

function compare(s, s$prime) {
  return l2$1(eq$1, Caml_obj.caml_compare, s, s$prime);
}

function $eq$eq(s, s$prime) {
  return l2$1(eq, (function (prim, prim$1) {
                return prim === prim$1;
              }), s, s$prime);
}

function $bang$eq(s, s$prime) {
  return l2$1(eq, (function (prim, prim$1) {
                return prim !== prim$1;
              }), s, s$prime);
}

function create$4(v) {
  return create$3(eq, v);
}

function equal$2(s, s$prime) {
  return equal$1(eq, s, s$prime);
}

function hold$1(v, e) {
  return hold(eq, v, e);
}

function app$2(sf, sv) {
  return app$1(eq, sf, sv);
}

function map$2(f, s) {
  return map$1(eq, f, s);
}

function filter$2(pred, i) {
  var partial_arg = eq;
  return (function (param) {
      return filter$1(partial_arg, pred, i, param);
    });
}

function fmap$2(fm, i) {
  var partial_arg = eq;
  return (function (param) {
      return fmap$1(partial_arg, fm, i, param);
    });
}

function when_(c, i, s) {
  return on$1(eq, c, i, s);
}

function dismiss$2(c, s) {
  var partial_arg = eq;
  return (function (param) {
      return dismiss$1(partial_arg, c, s, param);
    });
}

function accum$2(ef, i) {
  return accum$1(eq, ef, i);
}

function fold$3(f, i) {
  var partial_arg = eq;
  return (function (param) {
      return fold$2(partial_arg, f, i, param);
    });
}

function merge$2(f, a, sl) {
  return merge$1(eq, f, a, sl);
}

function $$switch$2(s) {
  return $$switch$1(eq, s);
}

function bind$2(s, sf) {
  return bind$1(eq, s, sf);
}

function fix$2(f) {
  var partial_arg = eq;
  return (function (param) {
      return fix$1(partial_arg, f, param);
    });
}

function l2$2(f, s, s$prime) {
  return l2$1(eq, f, s, s$prime);
}

function l3$2(f, s0, s1, s2) {
  return l3$1(eq, f, s0, s1, s2);
}

function l4$2(f, s0, s1, s2, s3) {
  return l4$1(eq, f, s0, s1, s2, s3);
}

function l5$2(f, s0, s1, s2, s3, s4) {
  return l5$1(eq, f, s0, s1, s2, s3, s4);
}

function l6$2(f, s0, s1, s2, s3, s4, s5) {
  return l6$1(eq, f, s0, s1, s2, s3, s4, s5);
}

function create$5(v) {
  return create$3(eq$1, v);
}

function equal$3(s, s$prime) {
  return equal$1(eq$1, s, s$prime);
}

function hold$2(v, e) {
  return hold(eq$1, v, e);
}

function app$3(sf, sv) {
  return app$1(eq$1, sf, sv);
}

function map$3(f, s) {
  return map$1(eq$1, f, s);
}

function filter$3(pred, i) {
  var partial_arg = eq$1;
  return (function (param) {
      return filter$1(partial_arg, pred, i, param);
    });
}

function fmap$3(fm, i) {
  var partial_arg = eq$1;
  return (function (param) {
      return fmap$1(partial_arg, fm, i, param);
    });
}

function when_$1(c, i, s) {
  return on$1(eq$1, c, i, s);
}

function dismiss$3(c, s) {
  var partial_arg = eq$1;
  return (function (param) {
      return dismiss$1(partial_arg, c, s, param);
    });
}

function accum$3(ef, i) {
  return accum$1(eq$1, ef, i);
}

function fold$4(f, i) {
  var partial_arg = eq$1;
  return (function (param) {
      return fold$2(partial_arg, f, i, param);
    });
}

function merge$3(f, a, sl) {
  return merge$1(eq$1, f, a, sl);
}

function $$switch$3(s) {
  return $$switch$1(eq$1, s);
}

function bind$3(s, sf) {
  return bind$1(eq$1, s, sf);
}

function fix$3(f) {
  var partial_arg = eq$1;
  return (function (param) {
      return fix$1(partial_arg, f, param);
    });
}

function l2$3(f, s, s$prime) {
  return l2$1(eq$1, f, s, s$prime);
}

function l3$3(f, s0, s1, s2) {
  return l3$1(eq$1, f, s0, s1, s2);
}

function l4$3(f, s0, s1, s2, s3) {
  return l4$1(eq$1, f, s0, s1, s2, s3);
}

function l5$3(f, s0, s1, s2, s3, s4) {
  return l5$1(eq$1, f, s0, s1, s2, s3, s4);
}

function l6$3(f, s0, s1, s2, s3, s4, s5) {
  return l6$1(eq$1, f, s0, s1, s2, s3, s4, s5);
}

function create$6(v) {
  return create$3(eq$2, v);
}

function equal$4(s, s$prime) {
  return equal$1(eq$2, s, s$prime);
}

function hold$3(v, e) {
  return hold(eq$2, v, e);
}

function app$4(sf, sv) {
  return app$1(eq$2, sf, sv);
}

function map$4(f, s) {
  return map$1(eq$2, f, s);
}

function filter$4(pred, i) {
  var partial_arg = eq$2;
  return (function (param) {
      return filter$1(partial_arg, pred, i, param);
    });
}

function fmap$4(fm, i) {
  var partial_arg = eq$2;
  return (function (param) {
      return fmap$1(partial_arg, fm, i, param);
    });
}

function when_$2(c, i, s) {
  return on$1(eq$2, c, i, s);
}

function dismiss$4(c, s) {
  var partial_arg = eq$2;
  return (function (param) {
      return dismiss$1(partial_arg, c, s, param);
    });
}

function accum$4(ef, i) {
  return accum$1(eq$2, ef, i);
}

function fold$5(f, i) {
  var partial_arg = eq$2;
  return (function (param) {
      return fold$2(partial_arg, f, i, param);
    });
}

function merge$4(f, a, sl) {
  return merge$1(eq$2, f, a, sl);
}

function $$switch$4(s) {
  return $$switch$1(eq$2, s);
}

function bind$4(s, sf) {
  return bind$1(eq$2, s, sf);
}

function fix$4(f) {
  var partial_arg = eq$2;
  return (function (param) {
      return fix$1(partial_arg, f, param);
    });
}

function l2$4(f, s, s$prime) {
  return l2$1(eq$2, f, s, s$prime);
}

function l3$4(f, s0, s1, s2) {
  return l3$1(eq$2, f, s0, s1, s2);
}

function l4$4(f, s0, s1, s2, s3) {
  return l4$1(eq$2, f, s0, s1, s2, s3);
}

function l5$4(f, s0, s1, s2, s3, s4) {
  return l5$1(eq$2, f, s0, s1, s2, s3, s4);
}

function l6$4(f, s0, s1, s2, s3, s4, s5) {
  return l6$1(eq$2, f, s0, s1, s2, s3, s4, s5);
}

var E = [
  /* Never */0,
  create$2,
  retain,
  stop$1,
  equal,
  trace,
  once,
  drop_once,
  app,
  map,
  stamp,
  filter,
  fmap,
  diff,
  changes,
  on,
  on,
  dismiss,
  until,
  accum,
  fold$1,
  select,
  merge,
  $$switch,
  fix,
  map,
  l2,
  l3,
  l4,
  l5,
  l6,
  $$Option
];

var S_031 = [
  /* Const */Block.__(0, [false]),
  /* Const */Block.__(0, [true]),
  not,
  $unknown$unknown,
  $pipe$pipe,
  edge,
  rise,
  fall,
  flip
];

var S_032 = [
  /* Const */Block.__(0, [0]),
  /* Const */Block.__(0, [1]),
  /* Const */Block.__(0, [-1]),
  $tilde$neg,
  succ,
  pred,
  $plus,
  $neg,
  $star,
  mod,
  abs,
  max_int,
  min_int,
  land,
  lor,
  lxor,
  lnot,
  lsl,
  lsr,
  asr
];

var S_033 = [
  /* Const */Block.__(0, [0]),
  /* Const */Block.__(0, [1]),
  /* Const */Block.__(0, [-1]),
  $tilde$neg$dot,
  $plus$dot,
  $neg$dot,
  $star$dot,
  $slash$dot,
  $star$star,
  sqrt,
  exp,
  log,
  log10,
  cos,
  sin,
  tan,
  acos,
  asin,
  atan,
  atan2,
  cosh,
  sinh,
  tanh,
  ceil,
  floor,
  abs_float,
  mod_float,
  frexp,
  ldexp,
  modf,
  $$float,
  float_of_int,
  truncate,
  int_of_float,
  infinity,
  neg_infinity,
  nan,
  max_float,
  min_float,
  epsilon_float,
  classify_float
];

var S_036 = [
  $eq,
  $less$great,
  $less,
  $great,
  $less$eq,
  $great$eq,
  compare,
  $eq$eq,
  $bang$eq
];

function S_037(funarg) {
  var eq = funarg[/* equal */0];
  var create$7 = function (v) {
    return create$3(eq, v);
  };
  var equal$5 = function (s, s$prime) {
    return equal$1(eq, s, s$prime);
  };
  var hold$4 = function (v, e) {
    return hold(eq, v, e);
  };
  var app$5 = function (sf, sv) {
    return app$1(eq, sf, sv);
  };
  var map$5 = function (f, s) {
    return map$1(eq, f, s);
  };
  var filter$5 = function (pred, i) {
    var partial_arg = eq;
    return (function (param) {
        return filter$1(partial_arg, pred, i, param);
      });
  };
  var fmap$5 = function (fm, i) {
    var partial_arg = eq;
    return (function (param) {
        return fmap$1(partial_arg, fm, i, param);
      });
  };
  var when_ = function (c, i, s) {
    return on$1(eq, c, i, s);
  };
  var dismiss$5 = function (c, s) {
    var partial_arg = eq;
    return (function (param) {
        return dismiss$1(partial_arg, c, s, param);
      });
  };
  var accum$5 = function (ef, i) {
    return accum$1(eq, ef, i);
  };
  var fold$6 = function (f, i) {
    var partial_arg = eq;
    return (function (param) {
        return fold$2(partial_arg, f, i, param);
      });
  };
  var merge$5 = function (f, a, sl) {
    return merge$1(eq, f, a, sl);
  };
  var $$switch$5 = function (s) {
    return $$switch$1(eq, s);
  };
  var bind$5 = function (s, sf) {
    return bind$1(eq, s, sf);
  };
  var fix$5 = function (f) {
    var partial_arg = eq;
    return (function (param) {
        return fix$1(partial_arg, f, param);
      });
  };
  var l2$5 = function (f, s, s$prime) {
    return l2$1(eq, f, s, s$prime);
  };
  var l3$5 = function (f, s0, s1, s2) {
    return l3$1(eq, f, s0, s1, s2);
  };
  var l4$5 = function (f, s0, s1, s2, s3) {
    return l4$1(eq, f, s0, s1, s2, s3);
  };
  var l5$5 = function (f, s0, s1, s2, s3, s4) {
    return l5$1(eq, f, s0, s1, s2, s3, s4);
  };
  var l6$5 = function (f, s0, s1, s2, s3, s4, s5) {
    return l6$1(eq, f, s0, s1, s2, s3, s4, s5);
  };
  return [
          /* create */create$7,
          /* equal */equal$5,
          /* hold */hold$4,
          /* app */app$5,
          /* map */map$5,
          /* filter */filter$5,
          /* fmap */fmap$5,
          /* when_ */when_,
          /* dismiss */dismiss$5,
          /* accum */accum$5,
          /* fold */fold$6,
          /* merge */merge$5,
          /* switch */$$switch$5,
          /* bind */bind$5,
          /* fix */fix$5,
          /* l1 */map$5,
          /* l2 */l2$5,
          /* l3 */l3$5,
          /* l4 */l4$5,
          /* l5 */l5$5,
          /* l6 */l6$5
        ];
}

var S_038 = [
  [
    create$4,
    equal$2,
    hold$1,
    app$2,
    map$2,
    filter$2,
    fmap$2,
    when_,
    dismiss$2,
    accum$2,
    fold$3,
    merge$2,
    $$switch$2,
    bind$2,
    fix$2,
    map$2,
    l2$2,
    l3$2,
    l4$2,
    l5$2,
    l6$2
  ],
  [
    create$5,
    equal$3,
    hold$2,
    app$3,
    map$3,
    filter$3,
    fmap$3,
    when_$1,
    dismiss$3,
    accum$3,
    fold$4,
    merge$3,
    $$switch$3,
    bind$3,
    fix$3,
    map$3,
    l2$3,
    l3$3,
    l4$3,
    l5$3,
    l6$3
  ],
  [
    create$6,
    equal$4,
    hold$3,
    app$4,
    map$4,
    filter$4,
    fmap$4,
    when_$2,
    dismiss$4,
    accum$4,
    fold$5,
    merge$4,
    $$switch$4,
    bind$4,
    fix$4,
    map$4,
    l2$4,
    l3$4,
    l4$4,
    l5$4,
    l6$4
  ]
];

var S = [
  $$const,
  create$3,
  value$1,
  retain$1,
  eq_fun,
  stop$2,
  equal$1,
  trace$1,
  hold,
  app$1,
  map$1,
  filter$1,
  fmap$1,
  diff$1,
  changes$1,
  sample,
  on$1,
  on$1,
  dismiss$1,
  accum$1,
  fold$2,
  merge$1,
  $$switch$1,
  bind$1,
  fix$1,
  map$1,
  l2$1,
  l3$1,
  l4$1,
  l5$1,
  l6$1,
  S_031,
  S_032,
  S_033,
  Pair,
  $$Option$1,
  S_036,
  S_037,
  S_038
];

var Step = [
  create,
  execute$1
];

exports.E = E;
exports.S = S;
exports.Step = Step;
/* nil Not a pure module */
